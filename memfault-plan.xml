<MemfaultSTM32Plan version="1.0">
  <Context>
    <GuideUrl>https://docs.memfault.com/docs/mcu/arm-cortex-m-guide?reboot-tracking-soc=STM32&amp;coredump-storage=STM32&amp;build-id-methods=gnu-build-id</GuideUrl>
    <TargetMCU>STM32 (Cortex-M) - STM32F401</TargetMCU>
    <HostOS>macOS</HostOS>
    <RepoRoot>/Users/athens/CascadeProjects/memfault-stm32-demo</RepoRoot>
    <Emulation>Renode</Emulation>
    <HAL>STM32CubeF4</HAL>
    <RenodePath>/Applications/Renode.app/Contents/MacOS/macos_run.command</RenodePath>
  </Context>

  <Prerequisites id="mem-1 mem-2">
    <Step id="mem-1" title="Create Memfault account/project">
      <Action>Create project in Memfault Cloud and retrieve Project Key</Action>
      <Output name="MEMFAULT_PROJECT_KEY">F6Wm0RMUXOI79msG9DVbcuh2OIqZepCW</Output>
      <Acceptance>Project key available</Acceptance>
    </Step>
    <Step id="mem-2" title="Toolchain and SDK deps">
      <Action>Install arm-none-eabi-gcc, CMake/Make, STM32Cube HAL, OpenOCD/ST-LINK</Action>
      <Command>brew install --cask gcc-arm-embedded</Command>
      <Command>brew install cmake open-ocd</Command>
      <Acceptance>Toolchain in PATH; can compile a trivial Cortex-M app</Acceptance>
    </Step>
    <Step id="mem-2a" title="Install and configure Renode for STM32F4 emulation (targeting F401)">
      <Action>Install Renode and prepare an STM32F4 (e.g., F407) platform script with UART exposed</Action>
      <Command>brew install renode</Command>
      <BinaryPath>/Applications/Renode.app/Contents/MacOS/macos_run.command</BinaryPath>
      <MakeCommandAvailable>
        <Option name="Alias (per-user)">
          <Shell>zsh</Shell>
          <Command>echo 'alias renode="/Applications/Renode.app/Contents/MacOS/macos_run.command"' >> ~/.zshrc && source ~/.zshrc</Command>
          <Note>Fastest; only affects your user shell.</Note>
        </Option>
        <Option name="Symlink (system PATH)">
          <Command>mkdir -p /usr/local/bin</Command>
          <Command>ln -s "/Applications/Renode.app/Contents/MacOS/macos_run.command" /usr/local/bin/renode</Command>
          <Alternative>ln -s "/Applications/Renode.app/Contents/MacOS/macos_run.command" /opt/homebrew/bin/renode</Alternative>
          <Note>Use /usr/local/bin on Intel Macs; /opt/homebrew/bin on Apple Silicon (Homebrew default).</Note>
        </Option>
        <Validation>
          <Command>which renode</Command>
          <Expected>/usr/local/bin/renode or /opt/homebrew/bin/renode</Expected>
        </Validation>
      </MakeCommandAvailable>
      <Config>
        <File>renode/stm32f4.resc</File>
        <Snippet># creates a UART telnet server on port 3456 for host collection</Snippet>
        <Snippet>emulation CreatePlatform</Snippet>
        <Snippet>machine LoadPlatformDescription @platforms/cpus/stm32f4_discovery.repl</Snippet>
        <Note>If a dedicated STM32F401/Nucleo board .repl is available in your Renode version, prefer that; otherwise the F4 Discovery platform is sufficient for UART-driven demos.</Note>
        <Snippet>sysbus.uart2 CreateTelnetServer "uart2" 3456</Snippet>
        <Snippet>sysbus LoadELF @firmware/build/app.elf</Snippet>
        <Snippet>start</Snippet>
      </Config>
      <Acceptance>Renode boots firmware and UART is reachable at localhost:3456</Acceptance>
    </Step>
  </Prerequisites>

  <ProjectSetup id="mem-3">
    <Step title="Create firmware skeleton (STM32F401)">
      <Action>Scaffold CMake or Make project for target STM32; add HAL, startup, linker script</Action>
      <Paths>
        <Dir>firmware/</Dir>
        <Dir>firmware/app/</Dir>
        <Dir>firmware/memfault/</Dir>
        <File>firmware/app/main.c</File>
        <File>firmware/linker/STM32F401.ld</File>
      </Paths>
      <Acceptance>Project builds ‘blinky’ without Memfault</Acceptance>
    </Step>
  </ProjectSetup>

  <SDKIntegration id="mem-4">
    <Step title="Add Memfault SDK">
      <Action>Vendor or submodule Memfault SDK into firmware/memfault</Action>
      <Command>git submodule add https://github.com/memfault/memfault-firmware-sdk firmware/memfault</Command>
      <Config>
        <File>firmware/memfault/ports/stm32/</File>
        <File>firmware/memfault/components/</File>
      </Config>
      <BuildIntegration>
        <CFlags>-DMEMFAULT_PLATFORM_STM32 -DMEMFAULT_USE_GNU_BUILD_ID</CFlags>
        <Includes>firmware/memfault/components/include</Includes>
        <Sources>memfault/core/*.c, memfault/ports/stm32/*.c</Sources>
      </BuildIntegration>
      <Acceptance>Build succeeds linking Memfault objects</Acceptance>
    </Step>
  </SDKIntegration>

  <PlatformPort id="mem-5">
    <Step title="Configure platform port">
      <Files>
        <File path="firmware/app/memfault_platform_port.c">Implement storage, reboot tracking, logging hooks</File>
        <File path="firmware/app/memfault_platform_config.h">Project key, sizes, feature toggles</File>
      </Files>
      <Config>
        <Define name="MEMFAULT_PROJECT_KEY">F6Wm0RMUXOI79msG9DVbcuh2OIqZepCW</Define>
        <DeviceInfo>
          <SoftwareType>app</SoftwareType>
          <SoftwareVersion>1.0.0</SoftwareVersion>
          <HardwareVersion>stm32-board-revA</HardwareVersion>
          <DeviceSerial>STM32-XXXXXX</DeviceSerial>
        </DeviceInfo>
        <CoredumpStorage>STM32 internal flash region per guide</CoredumpStorage>
        <RebootTracking>Enable early init in Reset_Handler or very early in main()</RebootTracking>
      </Config>
      <Acceptance>Memfault init runs; reboot reason recorded on boot</Acceptance>
    </Step>
  </PlatformPort>

  <BuildId id="mem-6">
    <Step title="Enable GNU Build ID">
      <Linker>
        <Flag>-Wl,--build-id</Flag>
        <EnsureBuildIdSection>.note.gnu.build-id retained</EnsureBuildIdSection>
      </Linker>
      <ExposeToMemfault>memfault_platform_swit_get_primary_software_component()</ExposeToMemfault>
      <Acceptance>memfaultctl in logs shows non-empty build_id; symbol present in ELF</Acceptance>
    </Step>
  </BuildId>

  <Transport id="mem-7">
    <Step title="Chunk transport implementation">
      <Option name="UART">Implement memfault_packetizer + CLI to print base64 chunks over UART</Option>
      <Option name="RTT">Use SEGGER RTT transport if available</Option>
      <CLI>
        <Command>memfault export coredump</Command>
        <Command>memfault export data</Command>
      </CLI>
      <HostCollection>
        <Tool>memfault-cli</Tool>
        <Command>pipx install memfault-cli</Command>
        <Command>memfault --project-key ${MEMFAULT_PROJECT_KEY} serial --port /dev/tty.usbmodemXXXX</Command>
        <Renode>
          <Note>When using Renode telnet UART (e.g., sysbus.uart2 on port 3456), point the CLI to a TCP-to-PTY bridge or capture UART output and paste chunks.</Note>
          <Option>Use `renode-serial-bridge` or `socat` to expose TCP 3456 as a local TTY</Option>
          <Example>socat -d -d pty,raw,echo=0 TCP:localhost:3456</Example>
        </Renode>
      </HostCollection>
      <Acceptance>Chunks emitted and accepted by CLI without parse errors</Acceptance>
    </Step>
  </Transport>

  <IntegrationVerification id="mem-iv">
    <Step title="Verify Memfault initialization logs">
      <Build>
        <Command>cmake -S firmware -B firmware/build -G "Unix Makefiles"</Command>
        <Command>cmake --build firmware/build -j</Command>
        <Output>firmware/build/app.elf</Output>
      </Build>
      <Run>
        <Command>renode -e "i @renode/stm32f4.resc"</Command>
        <Note>Semihosting enabled; logs appear in Renode console.</Note>
      </Run>
      <ExpectedLogs>
        <Line>[I] Memfault Build ID: &lt;hex SHA-like id&gt;</Line>
        <Line>[I] S/N: STM32F401-EMU-0001</Line>
        <Line>[I] SW type: app</Line>
        <Line>[I] SW version: 1.0.0</Line>
        <Line>[I] HW version: stm32f401-nucleo</Line>
        <Line>[I] Reset Reason, RESETREAS=0x&lt;val&gt;</Line>
        <Line>[I] Reset Causes:</Line>
        <Line>[I]  Software</Line>
        <Line>[I] Memfault Initialized!</Line>
      </ExpectedLogs>
      <Acceptance>All lines (or close equivalents) are printed on boot via memfault_platform_boot()</Acceptance>
    </Step>
  </IntegrationVerification>

  <MetricsAndEvents id="mem-8">
    <Step title="Enable heartbeat metrics and a test crash">
      <Metrics>Configure MEMFAULT_METRICS_* and populate counters (uptime, reboot count)</Metrics>
      <Crash>
        <Action>Add test path to trigger HardFault/assert for coredump</Action>
        <Command>memfault test crash</Command>
      </Crash>
      <Acceptance>Heartbeat event visible; crash produces coredump chunks</Acceptance>
    </Step>
  </MetricsAndEvents>

  <TestAndUpload id="mem-9">
    <Step title="Collect and upload">
      <Run>Flash firmware; open serial; trigger export</Run>
      <Commands>
        <Command>memfault serial --project-key ${MEMFAULT_PROJECT_KEY} --port /dev/tty.usbmodemXXXX</Command>
      </Commands>
      <Acceptance>CLI reports successful upload of chunks/events</Acceptance>
    </Step>
  </TestAndUpload>

  <CloudVerification id="mem-10">
    <Step title="Verify in Memfault Cloud">
      <Checks>
        <Check>Device appears with correct serial and build info</Check>
        <Check>Coredump is symbolicated</Check>
        <Check>Reboot events and metrics present</Check>
      </Checks>
      <Acceptance>All artefacts visible in dashboard; symbols match build</Acceptance>
    </Step>
  </CloudVerification>

  <ProjectFiles>
    <KeyFiles>
      <File>firmware/app/main.c</File>
      <File>firmware/app/memfault_platform_port.c</File>
      <File>firmware/app/memfault_platform_config.h</File>
      <File>firmware/linker/STM32XXXXX.ld</File>
      <File>firmware/CMakeLists.txt or Makefile</File>
    </KeyFiles>
  </ProjectFiles>

  <RisksAndNotes>
    <Note>Ensure dedicated flash region for coredump; do not overlap with app or bootloader</Note>
    <Note>Build ID must be preserved in linker script and not stripped</Note>
    <Note>Early init order matters for reboot tracking (run before RTOS start)</Note>
  </RisksAndNotes>
</MemfaultSTM32Plan>
